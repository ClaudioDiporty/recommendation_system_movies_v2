# -*- coding: utf-8 -*-
"""recommendation_system_movies_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JqnlYNUZxK_VTb9Bg-X4dWpHApT9jf_j

#Importação das Bibliotecas
"""

import pandas as pd
import numpy as np
from sklearn.neighbors import NearestNeighbors
from os import error
from scipy.sparse import csr_matrix

"""# Análise Exploratória dos Dados"""

movies = pd.read_csv('/content/drive/MyDrive/01-ARQUIVOS GOOGLE COLAB /RECOMMENDATION_SYSTEM/dataset_movies_v2/movies.csv')

movies.head(2)

movies.shape

ratings = pd.read_csv('/content/drive/MyDrive/01-ARQUIVOS GOOGLE COLAB /RECOMMENDATION_SYSTEM/dataset_movies_v2/ratings.csv')

ratings.head(2)

ratings.shape

"""# Pré Processamento"""

#Escolhendo as colunas que serão usadas no modelo
ratings = ratings[['userId', 'movieId','rating']]

ratings.head(2)

#Renomeando as colunas
movies = movies.rename(columns={'movieId': 'movie_id', })

movies.head(2)

ratings = ratings.rename(columns={'userId':'user_id','movieId':'movie_id' })

ratings.head(2)

#Verificando quantidade de Rating por usuário
ratings['user_id'].value_counts()
#Ex: id 668 teve 5678 avaliações

#Trazendo os ratings que teve mais de 10 avaliações de filmes
x = ratings['user_id'].value_counts() > 10

#Quantidade de usuário que fizeram mais de 10 avaliações de filmes
y = x[x].index
print(y.shape)

#Fazendo um Filtro
#Trazendo ratings somente dos usários que avaliaram mais de 10 filmes
ratings = ratings[ratings['user_id'].isin(y)]     #.isin() Função verifica se os valores estão contidos nas Séries. 
                                                  #Ele retorna uma série booleana mostrando se cada elemento na série 
                                                  #corresponde exatamente a um elemento na sequência de valores passada.

"""# Juntando as tabelas (Join ou Merge)"""

#Juntando tabela de filmes com tabela de rating
ratings_with_movies = movies.merge(ratings, on='movie_id')  # on= -> colocar  parâmetro que são comum nas duas tabelas

ratings_with_movies = ratings_with_movies[['user_id','movie_id','title','genres','rating']]

ratings_with_movies.head(3)

ratings_with_movies.shape

#Criar uma coluna que mostra quantidade de vezes que o filme foi avaliado
#Contar a quantidade de rating que teve nas avaliações
number_rating = ratings_with_movies.groupby('title')['rating'].count().reset_index()

number_rating.head(3)

#Renomear a tabela rating da number_rating
number_rating.rename(columns={'rating': 'number_of_ratings'}, inplace=True)

number_rating.head(3)

#Juntar numa Tabela Final a tabela 'ratings_with_movies' e a tabela 'number_rating'
final_rating = ratings_with_movies.merge(number_rating, on='title')

final_rating.head(5)

#Recolando as colunas para uma fácil visualização
final_rating = final_rating[['user_id', 'movie_id', 'rating', 'title', 'genres', 'number_of_ratings' ]]

final_rating.head(3)

final_rating.shape

#Fazendo Filtro
#Filtrar somente filmes que tiveram pelo menos 50 avaliações
final_rating = final_rating[final_rating['number_of_ratings'] >= 50]

final_rating.shape

#Descartar os valores duplicados, para não ter usuário avaliando o mesmo filmes várias vezes
final_rating.drop_duplicates(['user_id', 'title'], inplace=True)

final_rating.shape

"""# Transpor a Tabela Final usando pivot_table
#### transporos usuário em colunas, pois as avaliações dadas serão as variáveis da maquina preditiva
"""

movies_pivot = final_rating.pivot(columns='user_id', index='title', values='rating')

movies_pivot.head(5)

movies_pivot.shape

#Substituir os valores NaN por zeros
movies_pivot.fillna(0, inplace=True)   #fillna substitue valores nulos por outros valores

movies_pivot.head(5)

#Converter a tabela final, para uma matriz esparsa
#tabela de treinamento
movies_sparse = csr_matrix(movies_pivot)

"""# Criação do Sistema de Recomendação"""

#Executando o Treinamento do Algoritmo
model = NearestNeighbors(algorithm= 'brute', metric='manhattan')
model.fit(movies_sparse)

movies_pivot.shape

movies_pivot.head(455)

distances, suggestions = model.kneighbors(movies_pivot.iloc[452, :].values.reshape(1,-1))

for i in range(len(suggestions)):
  print(movies_pivot.index[suggestions[i]])